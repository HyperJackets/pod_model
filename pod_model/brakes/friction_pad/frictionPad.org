#+TITLE: Friction Pad
#+AUTHOR: Tarun Nadimpalli & Vishakh Kumar

Right now we are assuming a coefficient of .45, but that might change after thermal simulations.

[[file:frictionPad_connections.pdf]]


#+BEGIN_SRC python :tangle frictionPad.py
from pod_model.brakes.frriction_pad.brakeForce import BrakeForce
from pod_model.brakes.frriction_pad.frictionCoefficient import FrictionCoefficient
from pod_model.brakes.frriction_pad.heatConduction import HeatConduction
from pod_model.brakes.frriction_pad.heatConvective import HeatConvective
from pod_model.brakes.frriction_pad.heatGeneration import HeatGeneration
from pod_model.brakes.frriction_pad.temperatureChange import TemperatureChange

class FrictionPad(Group):

        ################# Inputs ##################
        # mu.SurfaceVelocity                      # 
        # brakeForce.NormalForce                  #
        # heatConvective.AreaBrakePad             #
        # heatConvective.TemperatureSurrounding   #
        # heatConduction.AreaContact              #
        # heatConduction.TemperatureContact       #
        # temperatureChange.Mass                  #
        ###########################################

        ################ Outputs ##################
        # brakeForce.FrictionForce                #
        # heatGeneration.HeatRateTrack            #
        ###########################################

    def setup(self):

        # Add subsystems and prmoted inputs and outputs

        self.add_subsystem('mu', FrictionCoefficient(), promotes='SurfaceVelocity')

        self.add_subsystem('heatConduction', HeatConduction(), promotes=['AreaContact','TemperatureContact'])
        self.add_subsystem('heatConvective', HeatConvective(), promotes=['AreaBrakePad','TemperatureSurrounding'])
        self.add_subsystem('heatGeneration', HeatGenerative(), promotes=['HeatRateTrack'])

        self.add_subsystem('brakeForce', BrakeForce(), promotes=['NormalForce','FrictionForce'])
        self.add_subsystem('temperatureChange', TemperatureChange(), promotes=['Mass'])

        # Internal Connections
        self.connect('mu.FrictionCoefficient', 'brakeForce.FrictionCoefficient')

        self.connect('brakeForce.FrictionForce', 'heatGeneration.BrakingForce')

        self.connect('heatGeneration.HeatRatePad','temperatureChange.HeatGenerated')
        self.connect('heatConduction.HeatRate','temperatureChange.HeatConduction')
        self.connect('heatConvective.HeatRate','temperatureChange.HeatConvection')

        self.connect('temperatureChange.NewTemperature',['mu.Temperature','heatConduction.TemperatureBrakePad','heatConvective.TemperatureBrakePad','temperatureChange.Temperature'])

    def configure(self):
        # This solver won't solve the sytem. We want
        # to override it in the parent.
        self.nonlinear_solver = NonlinearBlockGS()

#+END_SRC


** Brake Force

#+NAME: BrakeForce
#+CAPTION: BrakeForce
#+BEGIN_SRC python :tangle brakeForce.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class BrakeForce(ExplicitComponent):
    """Class to measure the brake force generated by the brake pads"""

    def initialize(self):
        """Declare options"""
        <<TemperatureChange_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<TemperatureChange_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<TemperatureChange_compute>>


#run stand-alone component
if __name__ == "__main__":

#    from openmdao.api import Group, Problem, IndepVarComp
#
#    comp = IndepVarComp()
#    comp.add_output('brake_temperature', val=3.0, lower=0, upper=10)
#    comp.add_output('mass_brake_pad', val=2.0, lower=1, upper=20)
#    comp.add_output('heat_conductive', val=1.0, lower=0, upper=10)
#    comp.add_output('heat_convective', val=1.0, lower=1, upper=20)
#    comp.add_output('heat_generated', val=100.0, lower=1, upper=20)
#
#    prob = Problem()
#    prob.model.add_subsystem('indep_var', comp)
#    prob.model.add_subsystem('my_comp', TemperatureChange())
#
#    prob.model.connect('indep_var.brake_temperature', 'my_comp.Temperature')
#    prob.model.connect('indep_var.mass_brake_pad',    'my_comp.Mass')
#    prob.model.connect('indep_var.heat_conductive',   'my_comp.HeatConduction')
#    prob.model.connect('indep_var.heat_convective',   'my_comp.HeatConvection')
#    prob.model.connect('indep_var.heat_generated',    'my_comp.HeatGenerated')
#
#
#    prob.setup()
#    prob.run_model()
#    print(prob['my_comp.NewTemperature'])
#+END_SRC

*** initialize
    No options required here

*** setup
**** inputs
#+NAME: BrakeForce_setup
#+BEGIN_SRC python 
self.add_input('FrictionCoefficient',
               1.,
               desc="Coefficient of friction of the friction pad.")
#+END_SRC

#+NAME: BrakeForce_setup
#+BEGIN_SRC python 
self.add_input('NormalForce',
               1.,
               desc="Normal Force applied to the friction pad.")
#+END_SRC

**** Outputs
The brake force generated by the friction pad
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_output('FrictionForce',
                0.45,
                desc="Friction Force generated by the friction pad")
#+END_SRC

*** compute
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
c_f = inputs["FrictionCoefficient"]
normal_force = inputs["NormalForce"]
#+END_SRC

#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
friction_force = c_f * normal_force
#+END_SRC

We assign our results to the proper output variables
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
outputs["FrictionForce"] = friction_force
#+END_SRC

** Temperature Change

#+NAME: TemperatureChange
#+CAPTION: TemperatureChange
#+BEGIN_SRC python :tangle temperatureChange.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class TemperatureChange(ExplicitComponent):
    """Class to measure the temperature change in the brake pads"""

    def initialize(self):
        """Declare options"""
        <<TemperatureChange_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<TemperatureChange_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<TemperatureChange_compute>>


#run stand-alone component
if __name__ == "__main__":

    from openmdao.api import Group, Problem, IndepVarComp

    comp = IndepVarComp()
    comp.add_output('brake_temperature', val=3.0, lower=0, upper=10)
    comp.add_output('mass_brake_pad', val=2.0, lower=1, upper=20)
    comp.add_output('heat_conductive', val=1.0, lower=0, upper=10)
    comp.add_output('heat_convective', val=1.0, lower=1, upper=20)
    comp.add_output('heat_generated', val=100.0, lower=1, upper=20)

    prob = Problem()
    prob.model.add_subsystem('indep_var', comp)
    prob.model.add_subsystem('my_comp', TemperatureChange())

    prob.model.connect('indep_var.brake_temperature', 'my_comp.Temperature')
    prob.model.connect('indep_var.mass_brake_pad',    'my_comp.Mass')
    prob.model.connect('indep_var.heat_conductive',   'my_comp.HeatConduction')
    prob.model.connect('indep_var.heat_convective',   'my_comp.HeatConvection')
    prob.model.connect('indep_var.heat_generated',    'my_comp.HeatGenerated')


    prob.setup()
    prob.run_model()
    print(prob['my_comp.NewTemperature'])
#+END_SRC

*** initialize

Need to have a list of heat capacities here. It depends on the material we're using so some proper defaults would be handy.
#+NAME: TemperatureChange_initialize
#+BEGIN_SRC python
self.options.declare('HeatCapacity',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Heat Capacity of the Friction Brakes")
#+END_SRC

*** setup
**** inputs
The current temperature of the brake pad. This isn't strictly needed but we use it to return an actual temperature instead of a difference in temperature
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Temperature',
               1.,
               desc="Temperature of the friction pad.")
#+END_SRC

The mass of the brake pad is a variable instead of an option because we might model the wear rate of the brake pad, which will reduce the mass
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Mass',
               1.,
               desc="Mass of the friction pad.")
#+END_SRC

The heat lost due to conduction as calculated by the HeatConduction component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConduction',
               1.,
               desc="Heat lost due to conduction")
#+END_SRC

The heat lost due to convection, as calculated by the HeatConvection Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConvection',
               1.,
               desc="Heat lost due to convection")
#+END_SRC

The heat generated by friction, as calculated by the HeatGeneration Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatGenerated',
               1.,
               desc="Heat created due to friction")
#+END_SRC

**** Outputs
The new temperature of the brake pad
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_output('NewTemperature',
                0.45,
                desc="Friction Force generated by the friction pad")
#+END_SRC

*** compute

First, we take the inputs and options and attach them to shorter variables. In the case of the Heat variables, we also ensure that they have the right sign.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
mass = inputs["Mass"]
temperature = inputs["Temperature"]
heat_capacity = self.options["HeatCapacity"]
        
time_step = 0.01

heat_convection = inputs["HeatConvection"]
heat_conduction = inputs["HeatConduction"]
heat_generated = inputs["HeatGenerated"]

if heat_convection > 0:
    heat_convection *= -1
if heat_conduction > 0:
    heat_conduction *= -1
if heat_generated < 0:
    heat_generated *= -1
#+END_SRC

The rate of total heat added to the system is the sum of the rate of generated heat and the rates of heat losses.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
heat_rate = heat_convection + heat_conduction + heat_generated
#+END_SRC

We calculate the temperature rise using a small time step and then add it to the new temperature
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
change_in_temperature = heat_rate/(mass*heat_capacity)*time_step

temperature += change_in_temperature
#+END_SRC

We assign our results to the proper output variables
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
outputs["NewTemperature"] = temperature
#+END_SRC

** Heat Generation

#+NAME: HeatGeneration
#+CAPTION: HeatGeneration
#+BEGIN_SRC python :tangle heatGeneration.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class HeatGeneration(ExplicitComponent):
    """Class to find the heat generated due to the braking force"""

    def initialize(self):
        """Declare options"""
        <<HeatGeneration_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<HeatGeneration_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<HeatGeneration_compute>>

#+END_SRC

*** initialize

Some experimental data would be really handy here. Not sure how to split it properly so for now, i'm calling it 50-50.
This is obviously begging for better defaults.
#+NAME: HeatGeneration_initialize
#+BEGIN_SRC python
self.options.declare('HeatRatePadRatio',
                     default=0.5,
                     types=np.ScalarType,
                     desc="The ratio of heat absorbed by the pad due to the brake force verses the total heat generated by the brake force")
#+END_SRC

*** setup
**** inputs
The braking force generated by the friction pad, as calculated by the BrakeForce Component
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_input('BrakingForce',
               1.,
               desc="Braking Force of the friction pad.")
#+END_SRC

The relative velocity between the friction pad and the track. Pretty much the speed of the pod
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_input('SurfaceVelocity',
               1.,
               desc="Velocity of the surface relative to the friction pad.")
#+END_SRC

**** Outputs
The heat generated that is absorbed by the friction pad
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_output('HeatRatePad',
                0.45,
                desc="Heat absorbed by the friction pad")
#+END_SRC

The heat generated that is absorbed by the track
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_output('HeatRateTrack',
                0.45,
                desc="Heat absorbed by the track")
#+END_SRC

*** compute

First, we take the inputs and options and attach them to shorter variables. In the case of the ratio variable, we also ensure that it lies between 0 and 1.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
braking_force = inputs["BrakingForce"]
surface_velocity = inputs["SurfaceVelocity"]

ratio = self.options["HeatRatePadRatio"]
assert ratio > 0 and ratio < 1 
#+END_SRC

We assume that the total work done by the braking force is converted to heat. Of course, some will be converted to light and sound but this is a model that ignores that.
The effect of this assumption is that our brakes don't get as hot in reality.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
total_heat_rate = braking_force * surface_velocity
#+END_SRC

Some part of the heat goes to the pad while the rest is rejected to the track. We use the ratio to figure out each quantity.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
heat_rate_pad = ratio * total_heat_rate
heat_rate_track = (1-ratio) * total_heat_rate
#+END_SRC

We assign the results to the proper output variables
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
outputs["HeatRatePad"] = heat_rate_pad
outputs["HeatRateTrack"] = heat_rate_track
#+END_SRC

** Heat Loss
*** Convective Heat Loss

 #+NAME: HeatConvective
 #+CAPTION: HeatGeneration
 #+BEGIN_SRC python :tangle heatConvective.py :noweb yes
 from openmdao.api import ExplicitComponent
 import numpy as np
 class HeatConvective(ExplicitComponent):
     """Class to find the heat generated due to the braking force"""

     def initialize(self):
         """Declare options"""
         <<HeatConvective_initialize>>

     def setup(self):
         """Declare inputs and outputs"""
         <<HeatConvective_setup>>

     def compute(self,inputs,outputs):
         """Compute outputs"""
         <<HeatConvective_compute>>

 #+END_SRC

**** initialize

 This is obviously begging for experimental data.
 #+NAME: HeatConvective_initialize
 #+BEGIN_SRC python
 self.options.declare('ConvectiveCoefficient',
                      default=0.5,
                      types=np.ScalarType,
                      desc="Convective Coefficient of the brake pad")
 #+END_SRC

**** setup
***** inputs

 The temperature of the brake pad
 #+NAME: HeatConvective_setup
 #+BEGIN_SRC python 
 self.add_input('TemperatureBrakePad',
                1.,
                desc="Temperature of the brake pad")
 #+END_SRC

 The temperature of the surroundings
 #+NAME: HeatConvective_setup
 #+BEGIN_SRC python 
 self.add_input('TemperatureSurrounding',
                1.,
                desc="Temperature of the surrounding")
 #+END_SRC


 The area subject to convective heat loss
 #+NAME: HeatConvective_setup
 #+BEGIN_SRC python 
 self.add_input('AreaBrakePad',
                1.,
                desc="Area subject to convective heat loss")
 #+END_SRC

***** Outputs
 The heat generated that is absorbed by the friction pad
 #+NAME: HeatConvective_setup
 #+BEGIN_SRC python 
 self.add_output('HeatRate',
                 0.45,
                 desc="Rate of heat lost through convection")
 #+END_SRC

**** compute

 #+NAME: HeatConvective_compute
 #+BEGIN_SRC python
 h = self.options["ConvectiveCoefficient"]
 assert h > 0, "Convective Coefficient must be positive"
 #+END_SRC

 #+NAME: HeatConvective_compute
 #+BEGIN_SRC python
 area = inputs["Area"]
 assert area > 0, "Area must be a positive non-zero quantity"
 #+END_SRC

 #+NAME: HeatConvective_compute
 #+BEGIN_SRC python
 sur_temp = inputs["TemperatureSurrounding"]
 pad_temp = inputs["TemperatureBrakePad"]
 assert pad_temp > sur_temp, "Surrounding temperature is greater than the pad temperature - Convection is impossible"
 #+END_SRC

 #+NAME: HeatConvective_compute
 #+BEGIN_SRC python
 temp_diff = pad_temp - sur_temp

 heat_loss = -(h * temp_diff * area)

 assert heat_loss < 0, "Heat Loss is always a negative quantity"
 #+END_SRC

 #+NAME: HeatConvective_compute
 #+BEGIN_SRC python
 outputs["HeatRate"] = heat_loss
 #+END_SRC





*** Conduction Heat Loss

 #+NAME: HeatConduction
 #+CAPTION: HeatConduction
 #+BEGIN_SRC python :tangle heatConduction.py :noweb yes
 from openmdao.api import ExplicitComponent
 import numpy as np
 class HeatConduction(ExplicitComponent):
     """Class to find the heat generated due to the braking force"""

     def initialize(self):
         """Declare options"""
         <<HeatConvective_initialize>>

     def setup(self):
         """Declare inputs and outputs"""
         <<HeatConvective_setup>>

     def compute(self,inputs,outputs):
         """Compute outputs"""
         <<HeatConvective_compute>>

 #+END_SRC

**** initialize

 This is obviously begging for better defaults and experiemntal data.

 #+NAME: HeatConduction_initialize
 #+BEGIN_SRC python
 self.options.declare('ThermalContactConductance',
                      default=0.5,
                      types=np.ScalarType,
                      desc="Thermal Contact Conductance between the brake pad and the body in contact with it")
 #+END_SRC

**** setup
***** inputs

 The temperature of the brake pad
 #+NAME: HeatConduction_setup
 #+BEGIN_SRC python 
 self.add_input('TemperatureBrakePad',
                1.,
                desc="Temperature of the brake pad")
 #+END_SRC

 The temperature of the surrounding area in contact with the brake pad, namely the piston
 #+NAME: HeatConduction_setup
 #+BEGIN_SRC python 
 self.add_input('TemperatureContact',
                1.,
                desc="Temperature of the surrounding area in contact with the Brake Pad (namely the piston)")
 #+END_SRC


 The area of the surroudning that is in contact with the brake pad
 #+NAME: HeatConduction_setup
 #+BEGIN_SRC python 
 self.add_input('AreaContact',
                1.,
                desc="Area subject to conductive heat loss")
 #+END_SRC


***** Outputs
 The heat generated that is absorbed by the friction pad
 #+NAME: HeatConduction_setup
 #+BEGIN_SRC python 
 self.add_output('HeatRate',
                 0.45,
                 desc="Rate of heat lost through conduction")
 #+END_SRC


**** compute

 #+NAME: HeatConduction_compute
 #+BEGIN_SRC python
 k = self.options["ThermalContactConductance"]
 assert k > 0, "Coefficient must be positive"
 #+END_SRC

 #+NAME: HeatConduction_compute
 #+BEGIN_SRC python
 area = inputs["Area"]
 assert area > 0, "Area must be a positive non-zero quantity"
 #+END_SRC

 #+NAME: HeatConduction_compute
 #+BEGIN_SRC python
 sur_temp = inputs["TemperatureSurrounding"]
 pad_temp = inputs["TemperatureBrakePad"]
 #+END_SRC

 #+NAME: HeatConduction_compute
 #+BEGIN_SRC python
 temp_diff = pad_temp - sur_temp

 heat_loss = -(k * temp_diff * area)

 assert heat_loss < 0, "Heat Loss is always a negative quantity"
 #+END_SRC

 #+NAME: HeatConduction_compute
 #+BEGIN_SRC python
 outputs["HeatRate"] = heat_loss
 #+END_SRC




** FrictionCoefficient

#+NAME: FrictionCoefficient
#+CAPTION: FrictionCoefficient
#+BEGIN_SRC python :tangle frictionCoefficient.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class FrictionCoefficient(ExplicitComponent):
    """Class to find the friction coefficient of the friction pad"""

    def initialize(self):
        """Declare options"""
        <<TemperatureChange_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<TemperatureChange_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<TemperatureChange_compute>>


#run stand-alone component
if __name__ == "__main__":

#    from openmdao.api import Group, Problem, IndepVarComp
#
#    comp = IndepVarComp()
#    comp.add_output('brake_temperature', val=3.0, lower=0, upper=10)
#    comp.add_output('mass_brake_pad', val=2.0, lower=1, upper=20)
#    comp.add_output('heat_conductive', val=1.0, lower=0, upper=10)
#    comp.add_output('heat_convective', val=1.0, lower=1, upper=20)
#    comp.add_output('heat_generated', val=100.0, lower=1, upper=20)
#
#    prob = Problem()
#    prob.model.add_subsystem('indep_var', comp)
#    prob.model.add_subsystem('my_comp', TemperatureChange())
#
#    prob.model.connect('indep_var.brake_temperature', 'my_comp.Temperature')
#    prob.model.connect('indep_var.mass_brake_pad',    'my_comp.Mass')
#    prob.model.connect('indep_var.heat_conductive',   'my_comp.HeatConduction')
#    prob.model.connect('indep_var.heat_convective',   'my_comp.HeatConvection')
#    prob.model.connect('indep_var.heat_generated',    'my_comp.HeatGenerated')
#
#
#    prob.setup()
#    prob.run_model()
#    print(prob['my_comp.NewTemperature'])
#+END_SRC

*** initialize

Need to have a list of heat capacities here. It depends on the material we're using so some proper defaults would be handy.
#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('SteadyStateFrictionCoefficient',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Coefficient of Friction at SteadyState")
#+END_SRC

#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('MultiplicationFactorSpeed',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Multiplication Factor caused by friction speed")
#+END_SRC

#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('MultiplicationFactorTempertature',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Multiplication Factor caused by rise in temperature")
#+END_SRC

#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('ParametricFactorSpeed',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Parametric Factor caused by friction speed")
#+END_SRC

#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('ParametricFactorTempertature',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Parametric Factor caused by rise in temperature")
#+END_SRC

#+NAME: FrictionCoefficient_initialize
#+BEGIN_SRC python
self.options.declare('OriginalTemperature',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Original Temperature")
#+END_SRC

*** setup
**** inputs
#+NAME: BrakeForce_setup
#+BEGIN_SRC python 
self.add_input('SurfaceVelocity',
               1.,
               desc="Velocity of the friction pad.")
#+END_SRC

#+NAME: BrakeForce_setup
#+BEGIN_SRC python 
self.add_input('Temperature',
               1.,
               desc="Temperature of the friction pad.")
#+END_SRC

**** Outputs
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_output('FrictionCoefficient',
                0.45,
                desc="Friction Coefficient of the friction pad")
#+END_SRC

*** compute
#+NAME: FrictionCoefficient_compute
#+BEGIN_SRC python
mu_d0 = self.options['SteadyStateFrictionCoefficient']
n_v = self.options['MultiplicationFactorSpeed']
n_t = self.options['MultiplicationFactorFrictionTempertature']
m_v = self.options['ParametricFactorSpeed']
m_t = self.options['ParametricFactorFrictionTempertature']
t_o = self.options['OriginalTemperature']
#+END_SRC

#+NAME: FrictionCoefficient_compute
#+BEGIN_SRC python
v = self.options["SurfaceVelocity"]
t = self.options["Temperature"]
#+END_SRC

#+NAME: FrictionCoefficient_compute
#+BEGIN_SRC python

import math

velocity_factor = 1 + n_v*math.exp(-(m_v*v))
temperature_factor = 1 + n_t*math.exp(-(m_t*(t-t_o)))
mu = mu_d0 * velocity_factor * temperature_factor
#+END_SRC

We assign our results to the proper output variables
#+NAME: FrictionCoefficient_compute
#+BEGIN_SRC python
outputs["FrictionCoefficient"] = mu
#+END_SRC


*** Unit tests

#+BEGIN_SRC python :tangle tests/test_frictionCoefficient.py
import pytest


testdata = [
    (1,0,0,0,0,5,[],[],[]),
    (1,0,0,0,0,5,[],[],[]),
]

@pytest.mark.parametrize("sFC,mFS,mFT,pFS,pFT,oT,fC", testdata)
def test_init(self,
              sFC, # steadyStateFrictionCoefficient,
              mFS, # multiplicationFactorSpeed,
              mFT, # multiplicationFactorTemperature,
              pFS, # parameticFactorSpeed,
              pFT, # parametricFactorTemperature,
              oT,  # originalTemperature,
              list_of_temperature, # list of temperatures to test at
              list_of_velocities,  # list of velocities to test at
              expected,            # expected frictionCoefficients

    from openmdao.api import Group, Problem, IndepVarComp

    comp = IndepVarComp()
    comp.add_output('SurfaceVelocity', val=3.0, lower=0, upper=10)
    comp.add_output('Temperature', val=2.0, lower=1, upper=20)

    my_comp = TemperatureChange(steadyStateFrictionCoefficient=sFC,
                                multiplicationFactorSpeed=mFS,
                                multiplicationFactorTemperature=mFT,
                                parameticFactorSpeed=pFS,
                                parametricFactorTemperature=pFT,
                                originalTemperature=oT,
                                )
    prob = Problem()
    prob.model.add_subsystem('indep_var', comp)
    prob.model.add_subsystem('my_comp', my_comp)

    prob.model.connect('indep_var.SurfaceVelocity', 'my_comp.SurfaceVelocity')
    prob.model.connect('indep_var.Temperature',    'my_comp.Temperature')
    prob.setup()
    prob.run_model()
    assert prob['my_comp.FrictionCoefficient'] == fC
#+END_SRC
