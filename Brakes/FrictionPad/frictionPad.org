#+TITLE: Friction Pad
#+AUTHOR: Tarun Nadimpalli & Vishakh Kumar

Right now we are assuming a coefficient of .45, but that might change after thermal simulations.


| Name                    | Numerical Quantity | Units |
|-------------------------+--------------------+-------|
| Coefficient of friction |               0.45 |     1 |

#+BEGIN_SRC python :tangle frictionPad.py
from openmdao.api import ExplicitComponent
import numpy as np
class FrictionPad(ExplicitComponent):
    """Aeroshell of the pod"""
    def initialize(self):
       """Declare options"""
    
        # Need to convert this to an input at some point
        self.options.declare('Mass', 
                             default=1.,
                             types=np.ScalarType,
                             desc='Mass of the Friction Pad')
        self.options.declare('FrictionCoefficient',
                             default=0.45,
                             types=np.ScalarType,
                             desc="Coefficient of Friction for the friction pad")

    def setup(self):
        """ Define inputs and ouputs"""
        
        # Inputs
        self.add_input('NormalForce',
                       default=1.,
                       types=np.ScalarType,
                       desc="Normal Force applied to the friction pad.")

        # Outputs
        self.add_output('FrictionForce',
                        default=0.45,
                        types=np.ScalarType,
                        desc="Friction Force generated by the friction pad")

    def compute(self, inputs, outputs):
        """Compute outputs"""
        
        # Properties of the friction pad
        c_f = self.options["FrictionCoefficient"]
        
        # Force applied to the friction pad
        normal = inputs["NormalForce"]
        
        friction = c_f * normal

        outputs["FrictionForce"] = friction

    def compute_partials(self,inputs,partials):
        """Computation of partial derivatives"""
        
        c_f = self.options["FrictionCoefficient"]
        
         partials["FrictionForce","NormalForce"] = c_f
#+END_SRC

** Temperature Change

#+NAME: TemperatureChange
#+CAPTION: TemperatureChange
#+BEGIN_SRC python :tangle temperatureChange.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class TemperatureChange(ExplicitComponent):
    """Class to measure the temperature change in the brake pads"""

    def initialize(self):
        """Declare options"""
        <<TemperatureChange_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<TemperatureChange_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""



#run stand-alone component
if __name__ == "__main__":

    from openmdao.api import Group, Problem, IndepVarComp

    comp = IndepVarComp()
    comp.add_output('brake_temperature', val=3.0, lower=0, upper=10)
    comp.add_output('mass_brake_pad', val=2.0, lower=1, upper=20)
    comp.add_output('heat_conductive', val=1.0, lower=0, upper=10)
    comp.add_output('heat_convective', val=1.0, lower=1, upper=20)
    comp.add_output('heat_generated', val=100.0, lower=1, upper=20)

    prob = Problem()
    prob.model.add_subsystem('indep_var', comp)
    prob.model.add_subsystem('my_comp', TemperatureChange())

    prob.model.connect('indep_var.brake_temperature', 'my_comp.Temperature')
    prob.model.connect('indep_var.mass_brake_pad',    'my_comp.Mass')
    prob.model.connect('indep_var.heat_conductive',   'my_comp.HeatConduction')
    prob.model.connect('indep_var.heat_convective',   'my_comp.HeatConvection')
    prob.model.connect('indep_var.heat_generated',    'my_comp.HeatGenerated')


    prob.setup()
    prob.run_model()
    print(prob['my_comp.NewTemperature'])
#+END_SRC

*** compute

First, we take the inputs and options and attach them to shorter variables. In the case of the Heat variables, we also ensure that they have the right sign.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
mass = inputs["Mass"]
temperature = inputs["Temperature"]
heat_capacity = self.options["HeatCapacity"]
        
time_step = 0.01

heat_convection = inputs["HeatConvection"]
heat_conduction = inputs["HeatConduction"]
heat_generated = inputs["HeatGenerated"]

if heat_convection > 0:
    heat_convection *= -1
if heat_conduction > 0:
    heat_conduction *= -1
if heat_generated < 0:
    heat_generated *= -1
#+END_SRC

The rate of total heat added to the system is the sum of the rate of generated heat and the rates of heat losses.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
heat_rate = heat_convection + heat_conduction + heat_generated
#+END_SRC

We calculate the temperature rise using a small time step and then add it to the new temperature
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
change_in_temperature = heat_rate/(mass*heat_capacity)*time_step

temperature += change_in_temperature
#+END_SRC

We assign our results to the proper output variables
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
outputs["NewTemperature"] = temperature
#+END_SRC

*** initialize

Need to have a list of heat capacities here. It depends on the material we're using so some proper defaults would be handy.
#+NAME: TemperatureChange_initialize
#+BEGIN_SRC python
self.options.declare('HeatCapacity',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Heat Capacity of the Friction Brakes")
#+END_SRC
*** setup
**** inputs
The current temperature of the brake pad. This isn't strictly needed but we use it to return an actual temperature instead of a difference in temperature
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Temperature',
               1.,
               desc="Temperature of the friction pad.")
#+END_SRC

The mass of the brake pad is a variable instead of an option because we might model the wear rate of the brake pad, which will reduce the mass
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Mass',
               1.,
               desc="Mass of the friction pad.")
#+END_SRC

The heat lost due to conduction as calculated by the HeatConduction component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConduction',
               1.,
               desc="Heat lost due to conduction")
#+END_SRC

The heat lost due to convection, as calculated by the HeatConvection Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConvection',
               1.,
               desc="Heat lost due to convection")
#+END_SRC

The heat generated by friction, as calculated by the HeatGeneration Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatGenerated',
               1.,
               desc="Heat created due to friction")
#+END_SRC
**** Outputs
The new temperature of the brake pad
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_output('NewTemperature',
                0.45,
                desc="Friction Force generated by the friction pad")
#+END_SRC


** Heat Generation
