#+TITLE: Friction Pad
#+AUTHOR: Tarun Nadimpalli & Vishakh Kumar

Right now we are assuming a coefficient of .45, but that might change after thermal simulations.


| Name                    | Numerical Quantity | Units |
|-------------------------+--------------------+-------|
| Coefficient of friction |               0.45 |     1 |

#+BEGIN_SRC python :tangle frictionPad.py
from openmdao.api import ExplicitComponent
import numpy as np
class FrictionPad(ExplicitComponent):
    """Aeroshell of the pod"""
    def initialize(self):
       """Declare options"""
    
        # Need to convert this to an input at some point
        self.options.declare('Mass', 
                             default=1.,
                             types=np.ScalarType,
                             desc='Mass of the Friction Pad')
        self.options.declare('FrictionCoefficient',
                             default=0.45,
                             types=np.ScalarType,
                             desc="Coefficient of Friction for the friction pad")

    def setup(self):
        """ Define inputs and ouputs"""
        
        # Inputs
        self.add_input('NormalForce',
                       default=1.,
                       types=np.ScalarType,
                       desc="Normal Force applied to the friction pad.")

        # Outputs
        self.add_output('FrictionForce',
                        default=0.45,
                        types=np.ScalarType,
                        desc="Friction Force generated by the friction pad")

    def compute(self, inputs, outputs):
        """Compute outputs"""
        
        # Properties of the friction pad
        c_f = self.options["FrictionCoefficient"]
        
        # Force applied to the friction pad
        normal = inputs["NormalForce"]
        
        friction = c_f * normal

        outputs["FrictionForce"] = friction

    def compute_partials(self,inputs,partials):
        """Computation of partial derivatives"""
        
        c_f = self.options["FrictionCoefficient"]
        
         partials["FrictionForce","NormalForce"] = c_f
#+END_SRC

** Temperature Change

#+NAME: TemperatureChange
#+CAPTION: TemperatureChange
#+BEGIN_SRC python :tangle temperatureChange.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class TemperatureChange(ExplicitComponent):
    """Class to measure the temperature change in the brake pads"""

    def initialize(self):
        """Declare options"""
        <<TemperatureChange_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<TemperatureChange_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<TemperatureChange_compute>>


#run stand-alone component
if __name__ == "__main__":

    from openmdao.api import Group, Problem, IndepVarComp

    comp = IndepVarComp()
    comp.add_output('brake_temperature', val=3.0, lower=0, upper=10)
    comp.add_output('mass_brake_pad', val=2.0, lower=1, upper=20)
    comp.add_output('heat_conductive', val=1.0, lower=0, upper=10)
    comp.add_output('heat_convective', val=1.0, lower=1, upper=20)
    comp.add_output('heat_generated', val=100.0, lower=1, upper=20)

    prob = Problem()
    prob.model.add_subsystem('indep_var', comp)
    prob.model.add_subsystem('my_comp', TemperatureChange())

    prob.model.connect('indep_var.brake_temperature', 'my_comp.Temperature')
    prob.model.connect('indep_var.mass_brake_pad',    'my_comp.Mass')
    prob.model.connect('indep_var.heat_conductive',   'my_comp.HeatConduction')
    prob.model.connect('indep_var.heat_convective',   'my_comp.HeatConvection')
    prob.model.connect('indep_var.heat_generated',    'my_comp.HeatGenerated')


    prob.setup()
    prob.run_model()
    print(prob['my_comp.NewTemperature'])
#+END_SRC

*** initialize

Need to have a list of heat capacities here. It depends on the material we're using so some proper defaults would be handy.
#+NAME: TemperatureChange_initialize
#+BEGIN_SRC python
self.options.declare('HeatCapacity',
                     default=1.0,
                     types=np.ScalarType,
                     desc="Heat Capacity of the Friction Brakes")
#+END_SRC

*** setup
**** inputs
The current temperature of the brake pad. This isn't strictly needed but we use it to return an actual temperature instead of a difference in temperature
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Temperature',
               1.,
               desc="Temperature of the friction pad.")
#+END_SRC

The mass of the brake pad is a variable instead of an option because we might model the wear rate of the brake pad, which will reduce the mass
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('Mass',
               1.,
               desc="Mass of the friction pad.")
#+END_SRC

The heat lost due to conduction as calculated by the HeatConduction component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConduction',
               1.,
               desc="Heat lost due to conduction")
#+END_SRC

The heat lost due to convection, as calculated by the HeatConvection Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatConvection',
               1.,
               desc="Heat lost due to convection")
#+END_SRC

The heat generated by friction, as calculated by the HeatGeneration Component
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_input('HeatGenerated',
               1.,
               desc="Heat created due to friction")
#+END_SRC

**** Outputs
The new temperature of the brake pad
#+NAME: TemperatureChange_setup
#+BEGIN_SRC python 
self.add_output('NewTemperature',
                0.45,
                desc="Friction Force generated by the friction pad")
#+END_SRC

*** compute

First, we take the inputs and options and attach them to shorter variables. In the case of the Heat variables, we also ensure that they have the right sign.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
mass = inputs["Mass"]
temperature = inputs["Temperature"]
heat_capacity = self.options["HeatCapacity"]
        
time_step = 0.01

heat_convection = inputs["HeatConvection"]
heat_conduction = inputs["HeatConduction"]
heat_generated = inputs["HeatGenerated"]

if heat_convection > 0:
    heat_convection *= -1
if heat_conduction > 0:
    heat_conduction *= -1
if heat_generated < 0:
    heat_generated *= -1
#+END_SRC

The rate of total heat added to the system is the sum of the rate of generated heat and the rates of heat losses.
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
heat_rate = heat_convection + heat_conduction + heat_generated
#+END_SRC

We calculate the temperature rise using a small time step and then add it to the new temperature
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
change_in_temperature = heat_rate/(mass*heat_capacity)*time_step

temperature += change_in_temperature
#+END_SRC

We assign our results to the proper output variables
#+NAME: TemperatureChange_compute
#+BEGIN_SRC python
outputs["NewTemperature"] = temperature
#+END_SRC


** Heat Generation

#+NAME: HeatGeneration
#+CAPTION: HeatGeneration
#+BEGIN_SRC python :tangle heatGeneration.py :noweb yes
from openmdao.api import ExplicitComponent
import numpy as np
class HeatGeneration(ExplicitComponent):
    """Class to find the heat generated due to the braking force"""

    def initialize(self):
        """Declare options"""
        <<HeatGeneration_initialize>>

    def setup(self):
        """Declare inputs and outputs"""
        <<HeatGeneration_setup>>

    def compute(self,inputs,outputs):
        """Compute outputs"""
        <<HeatGeneration_compute>>

#+END_SRC

*** initialize

Some experimental data would be really handy here. Not sure how to split it properly so for now, i'm calling it 50-50.
This is obviously begging for better defaults.
#+NAME: HeatGeneration_initialize
#+BEGIN_SRC python
self.options.declare('HeatRatePadRatio',
                     default=0.5,
                     types=np.ScalarType,
                     desc="The ratio of heat absorbed by the pad due to the brake force verses the total heat generated by the brake force")
#+END_SRC

*** setup
**** inputs
The braking force generated by the friction pad, as calculated by the BrakeForce Component
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_input('BrakingForce',
               1.,
               desc="Braking Force of the friction pad.")
#+END_SRC

The relative velocity between the friction pad and the track. Pretty much the speed of the pod
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_input('SurfaceVelocity',
               1.,
               desc="Velocity of the surface relative to the friction pad.")
#+END_SRC

**** Outputs
The heat generated that is absorbed by the friction pad
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_output('HeatRatePad',
                0.45,
                desc="Heat absorbed by the friction pad")
#+END_SRC

The heat generated that is absorbed by the track
#+NAME: HeatGeneration_setup
#+BEGIN_SRC python 
self.add_output('HeatRateTrack',
                0.45,
                desc="Heat absorbed by the track")
#+END_SRC

*** compute

First, we take the inputs and options and attach them to shorter variables. In the case of the ratio variable, we also ensure that it lies between 0 and 1.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
braking_force = inputs["BrakingForce"]
surface_velocity = inputs["SurfaceVelocity"]

ratio = self.options["HeatRatePadRatio"]
assert ratio > 0 and ratio < 1 
#+END_SRC

We assume that the total work done by the braking force is converted to heat. Of course, some will be converted to light and sound but this is a model that ignores that.
The effect of this assumption is that our brakes don't get as hot in reality.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
total_heat_rate = braking_force * surface_velocity
#+END_SRC

Some part of the heat goes to the pad while the rest is rejected to the track. We use the ratio to figure out each quantity.
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
heat_rate_pad = ratio * total_heat_rate
heat_rate_track = (1-ratio) * total_heat_rate
#+END_SRC

We assign the results to the proper output variables
#+NAME: HeatGeneration_compute
#+BEGIN_SRC python
outputs["HeatRatePad"] = heat_rate_pad
outputs["HeatRateTrack"] = heat_rate_track
#+END_SRC

